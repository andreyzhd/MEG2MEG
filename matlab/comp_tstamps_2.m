%   function [data_tstamps,nts,sfest,site_id] = comp_tstamps_2(inp,sforig,tcorr,offset)
%
%   Return the vector of the same length as inp, containing timestamps for
%   each entry of inp. For detecting timestamps use parameters defined
%   below (should match the parameters used for generating the timing
%   sequence).
%
%   Input:
%   inp           input vector of samples
%   sforig        sampling frequency (small errors are tolerated)
%   tcorr, offset (optional) coefficients for temporal coregistration of
%                 the computer clocks from the the two sites. Generated by
%                 COMP_TIME_CORR.
%
%   Return:
%   data_tstamps  interpolated timestamps for each sample (msec)
%   nts           number of detected timestamps
%   sfest         sampling frequency estimated from timestamps
%   site_id       id of the site where the the data was recorded
%

%--------------------------------------------------------------------------
%   Copyright (C) 2015 Department of Neuroscience and Biomedical Engineering,
%   Aalto University School of Science
%
%   This program is free software: you can redistribute it and/or modify
%   it under the terms of the GNU General Public License as published by
%   the Free Software Foundation, version 3.
%
%   This program is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%   GNU General Public License for more details.
%
%   You should have received a copy of the GNU General Public License
%   along with this program.  If not, see <http://www.gnu.org/licenses/>.
%--------------------------------------------------------------------------

function [data_tstamps,nts,sfest,site_id]=comp_tstamps_2(inp,sforig,tcorr,offset)

THRESH = 3;
BASELINE = 5;   % seconds
TRAIN_STEP = 0.015; % seconds
NBITS_TS = 42;          % excluding the parity bit
NBITS_ID = 5;          % excluding the parity bit

switch nargin
    case 2
        tcorr = [1, 0];
        offset = 0;
    case 4
    otherwise
        error('Incorrect number of input parameters');
end

% find all triggers (threshold crossings)
trigs = [];

for i = 1 : length(inp)-1
    if (inp(i) < THRESH) && (inp(i+1) > THRESH)
        trigs(end+1) = i+1;
    end
end

if isempty(trigs)
  data_tstamps=[];
  nts=0;
  sfest=nan;
  site_id=-1;
  return;
end

d = trigs(2:end) - trigs(1:end-1);

samps = [];
tss = [];
site_id = -1;

% iterate over all timestamp candidates
for i = find(d > BASELINE * sforig)
    ts = read_bits(d, i, TRAIN_STEP*sforig, NBITS_TS);
    if ts ~= -1
        samps(end+1) = trigs(i+1);
        tss(end+1) = ts;
        
        % read the site id
        cur_site_id = read_bits(d, i+NBITS_TS+1, TRAIN_STEP*sforig, NBITS_ID);
        if site_id == -1
            site_id = cur_site_id;
        else         
            if cur_site_id ~= -1
                % make sure all the timestamps have the same site id
                assert(site_id == cur_site_id);
            end
        end
    end
end

%fprintf('comp_tstamps: detected %d complete timestamps\n', length(tss));

% Correct timestamps
tss = polyval(tcorr, tss-offset) + offset;

nts=length(tss);

if nts==0
  data_tstamps=[];
  sfest=nan;
  return;
end

% fit timestamps to samples with linear regression
p=polyfit(samps,tss,1);
data_tstamps=([1:length(inp)]*p(1))+p(2);

sfest=1e3/p(1);

tserr=abs(p(1)*samps+p(2)-tss);
fprintf('comp_tstamps: %d timestamps, linear fit errors: max %g ms, mean %g ms\n',nts,max(tserr),mean(tserr));
if mean(tserr)>1
  fprintf('\ncomp_tstamps: WARNING: typically timestamps deviate <1 ms from the best linear fit.\n');
  fprintf('It may be that the PC clock was inappropriately adjusted during the recording.\n');
  fprintf('This may affect the synchronization accuracy.\n\n');
end

% return sf estimate
% TODO: error estimate for the sampling freq?
% TODO: outlier timestamps?

function res = read_bits(dtrigs, cur, step, nbits)
% READ_BITS - read and decode one sequence of bits (a single number of nbits + a
% parity bit).

res = 0;
parity = false;

for i = 1 : nbits + 1
    % end of input reached before NBITS bits read
    if cur+i > length(dtrigs)
        %warning('end of input reached before NBITS bits read');
        res = -1;
        return;
    end
    
    % invalid interval between two triggers
    if (dtrigs(cur+i) < step*1.5) || (dtrigs(cur+i) > step*4.5)
        %warning('invalid interval between two triggers');
        res = -1;
        return;
    end
    
    if dtrigs(cur+i) > step*3
        parity = ~parity;
        if i < nbits+1    % don't read the parity bit into the timestamp
            res = res + 2^(i-1);
        end
    end
end

if parity
    warning('parity check failed');
    res = -1;
end